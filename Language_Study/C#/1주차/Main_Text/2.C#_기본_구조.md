# C# 학습 1주차

## 목차

1.  **개요**
    1.  프로그램과 프로그래밍 언어
    2.  프로그래밍 언어의 분류
2.  **C# 기본 구조**
    1.  C#의 장점과 단점
    2.  가비지 컬렉터(Garbage Collector, GC)
    3.  C#의 기본 형식
    4.  C#의 기본 입출력 방법
3.  **C# 프로그램 생성 원리**
    1.  CLR과 중간 언어
4.  **자료형과 변수(Data Type & Variable)**
    1.  프로세스 메모리 구조
    2.  변수
    3.  값 형식과 참조 형식
    4.  C# 자료형의 종류
    5.  정수 자료형(Integer Type)
        1.  오버플로우(Overflow)와 언더플로우(UnderFlow)
    6.  문자 자료형(Character Type)
    7.  실수 자료형(Floating Point Type)
    8.  문자열 자료형(String Type)
    9.  논리 자료형(Boolean Type)
    10.  오브젝트 자료형(Object Type)
    11.  형변환(Type Conversion)
    12.  상수(Constant)
    13.  열거형(Enumeration Type)
    14.  Nullable 형식(Nullable Type)
    15.  var - 타입 추론 형식(Inference Type)
5.  **연산자(Operator)**
    1.  표현식이란?
    2.  연산자와 피연산자
    3.  전체 연산자 둘러보기
        1.  피연산자의 개수에 따라
        2.  연산자의 기능에 따라
    4.  연산자의 종류
        1.  대입 연산자(Assignment Operator)
        2.  산술 연산자(Arithmetic Operator)
        3.  증감 연산자(Increment/Decrement Operator)
        4.  관계 연산자(Relational Operator)
        5.  논리 연산자(Logical Operator)
        6.  비트 연산자(Bitwise Operator)
        7.  복합 대입 연산자(Additional Assignment Operator)
        8.  조건 연산자(Conditional Operator)
        9.  Null 관련 연산자(Null Type Operator)
        10.  그 밖의 연산자들
    5.  연산자 우선순위와 연산 방향

---

## 2. C# 기본 구조

### 2.1 C#의 장점과 단점 

**C#**은 마이크로소프트의 앤더스 헤일즈버그가 개발하였으며 C에 한 가지 기능(객체지향 패러다임)을 추가하였다는 의미의 **C++을 계승**하였다는 의미로 ++을 더 붙여(#의 형태를 생각해보면 +가 4개 있죠?) 이름붙여진 프로그래밍 언어입니다.

그러나 C#은 **C/C++과 이름은 비슷하지만 언어 구조나 원리가 완전히 다릅니다.** 오히려 C/C++에 비해 **언어 구조가 직관적이고 학습에 용이(저의 개인적인 생각으로도 지금까지 접한 언어들 중 가장 쉬웠습니다)**하다고 여기는 평가가 많습니다.

마이크로소프트는 **C#**의 발표와 함께 **.NET(닷넷 이라고 읽습니다) 이라는 프레임워크를 발표**하며 웹 서비스를 모든 플랫폼의 기기에서 사용할 수 있도록 하겠다는 비전을 발표하였습니다. 비록 현재 닷넷 프레임워크가 다른 웹 프레임워크에 비해서 각광받지는 못하지만, 이러한 비전을 반영한 **C#**은 **플랫폼의 제약 없이 동일한 프로그램 사용 경험을 받을 수 있도록 설계**되어 있습니다.

또한 .NET 프레임워크에 Windows OS의 다양한 기능을 간편하게 사용할 수 있는 클래스 라이브러리가 기본으로 제공되기 때문에 **Windows OS 에서 실행되는 프로그램에 가장 최적화된 프로그램 작성**이 가능합니다.

마지막으로 **현재 상용 게임 엔진 중 가장 인기 있고 많이 사용되는 게임 엔진**을 두 가지 뽑으라면 그 중에 항상 들어가게 되는 **Unity Engine의 스크립팅(게임이 작동하도록 작성하는 코드) 언어가 C#**이기 때문에 **게임 개발**에 있어서도 굉장히 중요한 위치를 차지하고 있습니다.

따라서 **C#의 장점**을 요약하면 다음과 같습니다.

*   **문법 구조가 굉장히 쉽다**
*   **Windows OS 기반 프로그램을 작성할 때 매우 편리하다**
*   **플랫폼의 제약이 없다**
*   **게임 개발에 용이하다**

장점이 있다면 단점도 존재하겠죠? C#의 단점은 다음과 같습니다.

*   모든 플랫폼에 제약을 없애기 위한 조치로 인해 **실행(런타임) 시 컴파일 비용이 많이 든다**

---

### 2.2. 가비지 컬렉터(Garbage Collector, GC)

C#은 C/C++과 이름은 비슷하지만 매우 다른 구조로 이루어져 있습니다.

특히 C/C++에는 존재하지 않지만 C#에는 존재하는 기능이 있는데, 바로 **가비지 컬렉터(Garbage Collector, GC)** 입니다.

가비지 컬렉터는 이름에서 알 수 있듯이 쓰레기를 수집하는 기능을 하는 요소인데요, C#에서 쓰레기란 **동적 메모리(힙) 안에서 더 이상 사용되지 않는 값**을 의미합니다.

**C**나 **C++**의 경우, **동적 할당을 통해 동적 메모리를 사용하고 나면 이를 프로그래머가 반드시 할당 해제시켜 주어야 합니다.** 그렇지 않다면 **해당 메모리가 끝까지 남아** 있어 **메모리 누수**를 일으키게 됩니다.

그러나 C#은 **GC** (앞으로 가비지 컬렉터를 GC라 칭하겠습니다)가 **더 이상 참조하지 않는 메모리를 알아서 찾아내 할당 해제**해 주므로 프로그래머가 메모리 이슈에 대해 전혀 신경 쓸 필요 없이 프로그래밍을 할 수 있도록 지원해줍니다.

가비지 컬렉터가 정확히 어떤 구조로 이루어져 있는지, 어떤 원리로 해제할 메모리를 찾아내는지는 나중에 다루도록 하겠습니다.

----

### 2.3 C#의 기본 형식

C#의 가장 기본적인 형태의 소스 코드를 확인해 본 후 문법의 기본 형식을 살펴보겠습니다.

```c#
/*예시 코드 2.1*/
using System;

namespace Hello
{
    class HelloProgram
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!"); // Hello World! 를 출력함
        }
    }
}
```

#### 1. Using 키워드

첫 번째 줄부터 살펴보면(예시 코드 2.1은 잠시 무시하세요.)

```c#
using System;
```

이는 System 이라는 **네임스페이스**에 **존재하는 모든 요소들을 사용**하겠다(가져오겠다) 라는 의미입니다.

또한 해당 코드 맨 뒤에 **세미콜론`;`** 을 찍어 명령어가 종료되었음을 표현합니다. 이처럼 C#은 **명령 구문 하나마다 맨 뒤에 세미콜론을 찍어야 하나의 구문이 끝났음을 컴파일러가 인식할 수 있습니다.**

#### 2. 네임스페이스(Namespace)

그렇다면  네임스페이스란 무엇일까요?

위 코드의 바로 아래 줄을 보면

```c#
namespace Hello
{
    ...
}
```

라는 코드가 있습니다.

**네임스페이스(Namespace)**란, C#의 모든 문법 요소들의 상위 집합(Superset)으로, 다양한 문법 요소들을 **중괄호**로 한 데 묶어주고 그 범위를 지정해주는 역할을 합니다.

프로그래밍을 작성하다 보면 여러 코드 안에 굉장히 많은 클래스(지금 당장은 몰라도 됩니다)와 구조체 등의 객체 요소들을 생성하는데, 이들의 이름은 중복될 수 없기 때문에 다 다른 이름을 지어 주어야 합니다. 그런데 그 객체를 표현하기 위해 필수적으로 나타내야 하는 이름이 있다면 어떻게 해야 할까요?

이러한 때 네임스페이스를 다르게 설정함으로써 이름의 중복을 피할 수 있습니다. 즉,

*   Hello 네임스페이스 안의 HelloProgram이라는 클래스
*   Bye 네임스페이스 안의 HelloProgram이라는 클래스

는 서로 다른 범위를 가지므로 구분될 수 있는 것이지요.

또한 네임스페이스는 이처럼 다양한 요소들을 한 데 묶어주는 패키지의 성격을 지니므로, 보통 관련 있는 기능의 요소들을 묶어 나타내는 용도로 사용합니다.

#### 3. 클래스(Class)

그 다음 코드는 아래와 같습니다.

```c#
class HelloProgram
{
    ...
}
```

여기서 class HelloProgram이라는 것은 HelloProgram이라는 **클래스**를 선언하는 것이고, **클래스(Class)** 란 프로그램 내에 존재할 수 있는 **객체(Object)** 의 **설계도**입니다. 

C#은 객체지향 패러다임에 입각한 코드 작성(만)을 지원하는 언어인데, 이 때 객체란 **자신만의 데이터(속성)와 메서드(기능)를 가질 수 있는 요소**를 의미합니다.

이러한 객체의 정의는 실제 현실에 존재하는 객체를 코드로 구현할 수 있도록 한 것입니다. 간단히 예를 들어서 '임용식'이라는 사람 객체가 있다고 가정해 봅시다.

'임용식'이라는 사람 객체는 다음과 같은 **데이터(속성)** 와 **기능(메서드)** 를 가집니다.

*   **데이터(속성)**
    -   이름
    -   나이
    -   키
    -   몸무게
    -   주량
    -   척추
    -   간
    -   ...
*   **기능(메서드)**
    -   숨쉬기
    -   걷기
    -   달리기
    -   잠자기
    -   술마시기
    -   ...

자세히 보면, **데이터**는 객체가 가진 **하나의 수치 또는 구성 요소**이며, **메서드**는 **행위**를 지칭하는 것임을 알 수 있습니다.

위의 코드에서 HelloProgram이라는 클래스

```c#
class HelloProgram
{
    static void Main(string[] args)
    {
        ...
    }
}
```

는 **Main이라는 메서드를 가지고 있으며, 어떠한 필드(앞으로는 데이터를 필드라 부르겠습니다)도 가지고 있지 않은 객체**입니다.

#### 4. Main(Main Method)

객체들은 다양한 메서드를 가질 수 있고, 가질 수 있는 개수에는 제한이 없습니다. 그러나 **Main이라는 메서드는 오직 하나의 객체가 하나만을 가져야 합니다.**

즉, 프로그램 전체에서 Main이라는 메서드는 반드시 단 하나 존재해야 한다는 것이죠.

왜 Main이라는 메서드는 반드시 하나(만) 필요할까요?

프로그램이 실행되게 되면, **프로그램은 가장 처음 어떤 코드를 실행해야 할 지 알 수 없습니다.** 그래서 C#(외에도 대부분의 프로그래밍 언어)는 **main이라는 이름을 가진 함수/메서드를 프로그램이 시작되면 최초로 실행되는 기능으로 지정해 놓았습니다.**

따라서 Main 메서드가 존재하지 않으면 프로그램은 어디서 시작해야 할 지 모르므로 컴파일을 진행할 수 없습니다.

마찬가지로 Main 메서드가 두 개 이상 존재한다면 중복된 Main 메서드 중 어떤 메서드를 실행해야 할 지 모르므로 컴파일을 진행할 수 없겠죠?(이처럼 컴파일러가 컴파일을 어떻게 진행해야 할 지 모르는 코드를 **모호한 코드 - Ambigious Code** 라고 합니다)

그러므로 **Main은 반드시 단 하나 존재해야 하며, 맨 앞에는 static 키워드가 붙어야 합니다** (이 static 키워드는 추후 설명하니 지금은 main 앞에 반드시 붙여야 한다는 것만 기억해주세요).

#### 5. Console.WriteLine()

다음으로 살펴볼 코드는 다음과 같습니다.

```c#
Console.WriteLine("Hello World!");
```

위 코드는 **C#의 대표적인 입력 메서드인 WriteLine 메서드**를 호출하는 코드입니다.

**WriteLine메서드는 오른쪽에 괄호를 입력하고 괄호 안에 출력을 원하는 데이터를 전달하면 해당 데이터를 콘솔에 출력시켜 줍니다.**

그런데 **WriteLine** 앞의 **Console**은 무슨 뜻일까요?

바로 Console 클래스 안에 있는 WriteLine이라는 뜻입니다.

앞서 네임스페이스가 이름이 같은 클래스들을 구별해 준다 한 것처럼, 클래스 역시 이름이 같은 메서드들을 구분해 줍니다.

그리고 Console 클래스가 가진 WriteLine을 사용한다는 의미에서 마침표`.`를 클래스명 뒤에 붙여줍니다.

이 때 이 마침표를 **범위 지정 연산자**라고 합니다.

따라서

```c#
Console.WriteLine
```

은

```C#
Console클래스 (의) WriteLine메서드
```

라는 의미이죠.

그런데 아까 우리는 클래스들의 상위집합이 **네임스페이스**라고 했습니다. 그럼 Console 클래스는 어떤 네임스페이스 안에 존재하는 걸까요?

눈치가 빠르다면 알아챘을 수 있겠지만, 바로 **System**네임스페이스 안에 존재합니다.

우리가 Using키워드를 통해 System 네임스페이스 안의 모든 것을 사용한다고 했으므로 Console클래스를 이용할 수 있게 된 것이죠.

그런데 사실 Using키워드를 따로 지정하지 않더라도 C#은 같은 디렉터리 안에 존재하는 모든 코드에 접근할 수 있습니다.

예시로, 두가지 코드를 보여드리겠습니다.

```c#
/*예제 코드 2.2*/
namespace Hello
{
    class HelloProgram2
    {
        System.Console.WriteLine("using 없이 System 네임스페이스 참조");
    }
}

```

위 코드는 using System; 이라는 코드 없이 Console 클래스 안의 WriteLine 메서드를 실행시키는 모습을 보여줍니다.

**네임스페이스 역시 범위 지정 연산자를 사용해서 접근할 수 있음**을 파악할 수 있습니다.

다음 코드도 한번 살펴보죠.

```c#
using System;
using static System.Console;

namespace Hello
{
    class HelloProgram3
    {
        WriteLine("Console 범위 지정 없이 WriteLine 사용");
    }
}
```

위처럼 **클래스도 using 키워드를 이용하면 별도의 표기 없이 바로 사용할 수 있습니다** (앞에 static이 붙은 이유는 Console 클래스가 static 클래스이기 때문입니다. 자세한 건 추후 설명합니다.).

결론적으로 **using 키워드는 자주 사용하는 네임스페이스/클래스 안의 요소들을 적은 타이핑으로 사용하기 위한 키워드**임을 알 수 있습니다.

#### 6. 주석(Comment)

예시 코드 안에 있지만 지금까지 무시했던 요소들을 살펴봅시다.

```c
/*예시 코드 2.1*/

// Hello World! 를 출력함
```

위 요소들은 **주석(Comment)** 이라고 부르며, 코드 내에서 컴파일러가 인식하지 못하는 구문입니다.

즉 **주석은 오로지 사람들에게만 보이는 요소**입니다.

컴파일러가 인식하지 못하는 요소가 왜 존재하는 것일까요? 정답은 바로 **사람들 간의 소통**을 위해서입니다.

**프로그램을 작성하다 보면 필연적으로 여러 개발자들이 협업을 하게 되는데, 이 때 각자 자신이 짠 코드를 설명하고 그 의도를 밝혀야 하기 마련**입니다.

이 때 **주석을 이용해 그러한 것들을 메모 형태로 남길 수 있습니다.**

또, 남들 뿐만 아니라 **혼자 프로그램을 작성할 때**에도 프로그램 볼륨이 커지면 **자신이 작성한 코드의 의도를 잊거나 헷갈리게 되는데, 그 때를 대비해 주석을 남겨놓는 경우도 매우 빈번합니다.**

그러므로 주석을 잘(**많이 작성하는 게 중요한 게 아니라 잘!**) 작성하는 습관을 미리미리 들여 놓으시면 사람들과 함께 개발할 때 사랑받는 동료가 될 수 있을 것입니다.

---

*C) 2021. Im-Yongsik(Hamsik2rang) all rights reserved.*

<div style="text-align:left"> <a href="./1.개요.md">← 개요</a><div/>
<div style="text-align:right"> <a href="./Main_Text/3.C#_프로그램_생성_원리.md">C# 프로그램 생성 원리 →</a><div/>


