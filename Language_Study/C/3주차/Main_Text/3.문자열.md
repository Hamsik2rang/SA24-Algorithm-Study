# C 학습 3주차

## 목차

1.  **배열**
    1.  배열의 정의
    2.  배열의 선언과 사용
    3.  배열의 초기화
    4.  배열의 활용
2.  **다차원 배열**
    1.  이차원 배열의 정의
    2.  이차원 배열의 선언과 사용
    3.  이차원 배열의 초기화
    4.  다차원 배열
    5.  다차원 배열의 활용
3.  **문자열**
    1.  C 문자열의 정의
    2.  문자 배열의 선언과 사용
    3.  문자 배열의 초기화
    4.  문자 배열 사용 시 주의사항
4.  **문자열 배열**
    1.  문자열 배열의 정의
    2.  문자열 배열의 선언, 사용과 초기화
5.  **표준 문자열 라이브러리**
    1.  라이브러리란?
    2.  표준 문자열 라이브러리
    3.  strcpy - 문자열의 복사
    4.  strlen - 문자열의 길이
    5.  strcmp - 문자열의 비교
    6.  strcat - 문자열의 연결

---

## 1. C 문자열의 정의

지금까지 본 여러 설명이나 예시 코드에서 우리는 **문자열**을 사용해 왔습니다.

예를 들어, 대부분의 경우에 프로그래밍 언어를 처음 배울 때 작성하는 코드인 **Hello World 출력** 프로그램이 그러한 예 중 하나입니다.

```c
#include <stdio.h>

int main()
{
    printf("Hello World!");
    
    return 0;
}
```

여기서 printf 안에 **문자열(문장)** 을 작성하였는데, 이 문자열을 만약에 입력을 받거나, 변수에 저장하려면 어떻게 해야 할까요?

그 전에 C의 문자열을 정의해야 하는데, C에서 문자열은 다음과 같습니다.

**큰따옴표`""`로 감싸진 하나 이상의 연속된 문자 집합**

즉, 문자 여러 개를 연속적으로 저장하면 그 **연속된 문자 집합**은 문자열이 됩니다. 그런데 여기서, **연속된 문자 집합**이라는 말이 뭔가 익숙하지 않나요?

맞습니다. C에서 문자열은 **문자들을 저장한 배열**로 표현/저장하게 됩니다.

따라서

```c
"Hello"
```

라는 문자열은 사실

```c
'H','e','l','l','o','\0'
```

라는 **문자들이 배열 안에 연속적으로 들어있는 배열 데이터**입니다.... 잠깐, 문자들 중에 뭔가 이상한 문자가 들어있지 않나요?

C에서는 문자 배열을 통해 문자열을 표현할 때 어디서 문자열이 끝나는지를 표현하기 위해 맨 뒤에 **널 문자`\0` **를 붙여 구분합니다.

따라서 위의 예시 코드에도 나왔듯이 **문자열을 printf로 출력**하게 되면

```c
printf("Hello World!")
```

printf함수는 **"Hello World!"** 라는 문자열의 시작인 **H**부터 배열의 인덱스를 1씩 증가시켜 나가며 문자를 순서대로 출력하다가 **널 문자(\0)** 를 만나면 출력을 멈추고 함수를 종료합니다.

그럼 이제 C의 문자열이 사실은 문자들을 순서대로 저장한 배열임을 알게 되었으니 문자 배열을 이용해 문자열을 저장/사용하는 방법을 알아봅시다.

## 2. 문자 배열의 선언과 사용

문자 배열은 문자들을 저장하는 배열이고, 각각의 문자는 일반적으로 **char** 자료형에 저장되므로 다음과 같이 선언합니다.

```c
char 배열명[문자열_길이+1];
```

여기서 왜 배열의 길이를 저장할 문자열 길이에 1을 더할까요? 우리가 이번 페이지에서 지금까지 살펴본 내용 중에 정답이 있습니다.

바로 **모든 문자열엔 널 문자가 포함되기 때문**입니다.

Hello라는 문자열을 저장하기 위해 배열을 선언한다고 가정하면, Hello라는 문자열은 H,e,l,l,o라는 5개의 문자와 널 문자가 합쳐져 총 6개의 문자가 들어가므로 배열의 크기도 6이 되어야만 합니다.

만약 널문자를 감안하지 않고 배열의 크기를 정한 뒤에 해당 배열에 문자열을 저장하게 되면, **유효 인덱스의 범위를 벗어나서 에러가 발생**하게 되니 반드시 주의해야 합니다.

이러한 특징에 주의해서 문자 배열을 선언했다면 문자 배열에 문자열을 저장해 보기도 해야겠죠?

문자 배열에 문자열은 다음처럼 저장할 수 있습니다.

```c
#include <stdio.h>

int main()
{
    char arr[6];
    
    arr[0] = 'H';
    arr[1] = 'e';
    arr[2] = 'l';
    arr[3] = 'l';
    arr[4] = 'o';
    arr[5] = '\0';
    
    printf(arr);
    
    return 0;
}
```

위 코드의 출력 결과는 다음과 같습니다.

```c
Hello
```

문자 배열에 문자열을 저장할 때에도 꼭 뒤에 널 문자를 넣어야 한다는 것을 알아두세요.

정상적으로 문자열을 문자 배열에 저장하고 출력까지 해냈지만 뭔가 불편합니다. 배열의 원소 각각에 문자를 넣지 않고 문자열을 한 번에 넣는 방법은 없을까요?

고민을 잠시 간직한 채로 문자 배열의 초기화를 하는 방법을 살펴보러 가겠습니다.

## 3. 문자 배열의 초기화

배열을 선언한 뒤에 값을 넣어주지 않고, 선언과 동시에 값을 넣어주는 초기화가 가능했던 것처럼, 문자 배열도 초기화가 가능합니다.

```c
char arr[6] = {'H','e','l','l','o','\0'};
```

여기까지는 배열을 잘 익히고 온 분들이라면 당연하게 여길 것입니다.

그런데 추가로, C에서는 우리가 직전에 가진 고민을 해결하기 위한 문자 배열만의 초기화 방법을 제공합니다.

문자열을 저장하고자 하는 배열에는 다음과 같은 초기화가 가능합니다.

```c
char arr[6] = "Hello";
```

이러한 식으로 초기화를 진행하면 배열 안에 자동으로 r-value의 문자열의 문자 하나하나가 배열에 순서대로 저장되게 됩니다. 물론 **"Hello"** 안에는 **널 문자**도 포함되어 있을 것이므로 따로 우리가 신경쓰지 않아도 마지막에 자동으로 **널 문자**가 들어가게 됩니다.

그래서 일반적으로 배열에 문자열 리터럴(문자열 상수)을 저장할 때에는 위와 같은 방법을 이용합니다.

호기심이 많은 분들은, 위와 같은 문자 배열의 초기화가 가능한 것을 보고 다음과 같은 궁금함을 가질 수도 있습니다.

>```c
>char arr[6] = "Hello";
>```
>
>가 가능하다면
>
>```c
>char arr[6];
>arr = "Hello";
>```
>
>도 가능한 것 아닌가?

실제로 위 코드를 직접 타이핑해 보면, 빌드를 진행하기도 전에 컴파일러가 해당 명령 밑에 빨간줄을 찍 그어버리는 것을 알 수 있습니다. 올바르지 못한 문법이라는 뜻이죠.

왜 초기화를 할 때에는 문자열을 통째로 대입할 수 있는데 선언된 배열에는 문자열을 한번에 대입할 수 없을까요?

이는 **C에서 저장된 문자열을 사용하는 방법**과 **배열의 이름의 진짜 의미**를 정확히 알아야 이해할 수 있습니다.

두 개념 중 배열의 이름의 진짜 의미에 대해서는 **포인터**를 알아야만 정확히 이해할 수 있으므로, 이번 시간에는 첫 번째 개념을 알아보고 두 번째 개념을 **간략히** 알아보겠습니다.

## 4. 문자 배열 사용 시 주의사항

이번 단락의 제목은 **문자 배열 사용 시 주의사항** 이지만, 여러분이 실제로 문자 배열을 사용할 때 주의해야 할 점은 이미 여러 번 설명드렸습니다.

바로 **널 문자를 잊지 말 것** 입니다.

그리고 한 가지 더, **한글**의 경우 **아스키 코드**가 아닌 **유니코드**를 통해 정의되기 때문에 한글 문자 하나당 2Byte의 크기를 가집니다. 따라서 한글이 포함된 문자열을 배열에 저장하고자 한다면 배열의 크기를 잘 산정해야 합니다.

```c
#include <stdio.h>

int main()
{
    char engString[] = "Hello";
    char korString[] = "안녕하세요";
    
    printf("\"Hello\" 의 길이 : %d Bytes", sizeof(engString));
    printf("\"안녕하세요\" 의 길이 : %d Bytes", sizeof(engString));
    
    return 0;    
}
```

위 코드의 출력 결과는 다음과 같습니다.

```text
"Hello" 의 길이 : 6 Bytes
"안녕하세요" 의 길이 : 11 Bytes
```

그 외에는 아무런 주의해야 할 사항이 없습니다. 그저 배열을 사용할 때 주의하던 부분만 지켜서 똑같이 사용하면 됩니다!

그러므로 우리는 논제를 바꿔서 직전에 얘기했던 **C에서 저장된 문자열을 사용하는 방법**과 **배열의 이름의 진짜 의미**를 알아보겠습니다.

C에서 문자열, 정확히 **문자열 리터럴(문자열 상수)** 는 **RAM**에 저장되지 않습니다.

첫 번째 주차에서 컴퓨터는 주 기억 장치로 **RAM**과 **ROM**을 사용한다고 언급하였는데, **문자열 상수**의 경우 다른 값들과 달리 **ROM**에 저장됩니다.

왜냐하면 문자열은 길이가 정해지지 않고, 프로그램에 따라 매우 많은 문자열이 사용될 수도 있기 때문입니다(미연시 게임을 생각해 보세요..).

그 많은 문자들을 RAM에 저장하면 메모리 용량이 매우 부족할 것이기 때문에, RAM 절약을 위해 문자열 상수들은 ROM에 저장하도록 한 것입니다.

그리고 ROM은 RAM과 달리 프로그램이 직접 접근할 수 없기 때문에 ROM에 저장된 문자열 리터럴들은 ROM에 저장되는 순간 **ROM 안에 저장된 문자열의 시작 주소**를 반환합니다. 그 주소를 이용해 프로그램은 문자열이 필요할 때 해당 주소에 접근해 저장된 문자열을 읽는 것이죠.

일반적으로 **값(Value)**과 **주소(Address)**는 완전히 다른 개념입니다. 값과 주소 모두 정수로 표현될 수는 있지만, **값을 저장하는 변수**들에 **주소**를 저장할 수는 없습니다. 주소는 **주소를 저장하는 변수(포인터)** 에만 담을 수 있습니다. 그리고 **배열**은 값을 저장하는 변수이죠.

따라서 배열에 문자열을 한번에 저장하는 것이 불가능한 것입니다.

그리고 하나 더 미리 알아두어야 할 것은 **배열의 이름** 역시 배열의 주소라는 것입니다.

문자열은 사용할 때 해당 문자열의 시작 주소를 이용한다고 했었죠?

우리가 맨 처음에 **"Hello World"** 를 출력할 때에는 다음과 같이 출력했습니다.

```c
printf("Hello World");
```

그리고 **"Hello"를 담은 배열**을 출력할 때에도 다음과 같이 출력했었죠.

```c
char arr[6] = "Hello";

printf(arr);
```

"Hello World" 가 문자열의 시작 주소이고, 문자열의 시작 주소를 printf에 넣어서 문자열을 출력했는데 배열의 이름을 넣어도 동일하게 문자열이 출력된다는 것은 배열의 이름이 배열의 시작 주소이기 때문입니다.

정확히 왜 그런지는 이후 포인터에 대해 배워야 알 수 있지만, 지금은 이 정도만 알아 두셔도 충분합니다.

참고로, 배열의 이름이 배열의 시작 **주소**이기 때문에 배열을 scanf로 출력할 때에도 배열 앞에 &를 붙이지 않고 이름만 전달하면 문자열을 입력받을 수 있습니다.

```c
#include <stdio.h>

int main()
{
    char arr[6] = "Hello";
    
    scanf("%s", arr);
    
    printf("%s", arr);
    
    return 0;
}
```

보면 문자열을 출력하거나 입력받을 때에는 **형식 지정자**에 **`%s`** 를 사용하는 것을 알 수 있습니다. 여기서 s는 string(문자열)을 의미합니다.

----

*(C) 2021. Im-Yongsik(Hamsik2rang) all rights reserved.*

<div style="text-align:left"> <a href="./2.다차원_배열.md">← 다차원 배열</a><div/>
<div style="text-align:right"> <a href="./4.문자열_배열.md">문자열 배열 →</a><div/>







