# C 학습 3주차

## 목차

1.  **배열**
    1.  배열의 정의
    2.  배열의 선언과 사용
    3.  배열의 초기화
    4.  배열의 활용
2.  **다차원 배열**
    1.  이차원 배열의 정의
    2.  이차원 배열의 선언과 사용
    3.  이차원 배열의 초기화
    4.  다차원 배열
    5.  다차원 배열의 활용
3.  **문자열**
    1.  C 문자열의 정의
    2.  문자 배열의 선언과 사용
    3.  문자 배열의 초기화
    4.  문자 배열 사용 시 주의사항
4.  **문자열 배열**
    1.  문자열 배열의 정의
    2.  문자열 배열의 선언, 사용과 초기화
5.  **표준 문자열 라이브러리**
    1.  라이브러리란?
    2.  표준 문자열 라이브러리
    3.  strcpy - 문자열의 복사
    4.  strlen - 문자열의 길이
    5.  strcmp - 문자열의 비교
    6.  strcat - 문자열의 연결

---

## 1. 라이브러리란?

**라이브러리(Library)** 라는 단어의 뜻은 **도서관**입니다. 도서관에서는 수많은 책들이 준비되어 있어 공부를 하다 궁금한 지식이 있거나 읽고 싶은 책이 있다면 언제든지 원하는 책을 꺼내와 읽을 수 있죠. 프로그래밍에서의 **라이브러리(Library, .lib)** 역시 마찬가지로 프로그래머들이 프로그램을 작성하는 도중 사용할 가능성이 있는 수많은 **코드들을 함수의 형태로 미리 만들어 놓은 파일**입니다.

물론 라이브러리는 일반적으로 함부로 수정될 수 없도록 **기계어**의 형태로 구성되어 있기 때문에, 이를 사용하기 위해선 해당 라이브러리에 들어있는 여러 기능들의 선언부인 **헤더 파일(.h)** 을 본인의 프로그램에 **포함**시켜야 합니다.

우리가 지금까지 작성한 코드들은 하나같이 코드의 맨 처음에 다음과 같은 구문을 포함시켰습니다.

```c
#include <stdio.h>
```

이 구문은 **stdio (Standard Input/Output)** 라는 라이브러리 파일의 **헤더(.h)** 를 **포함(include)** 시키라고 전처리문을 통해 컴파일러에게 요청하는 구문입니다.

헤더 파일의 이름에서 알 수 있듯이 stdio는 **표준 입출력 라이브러리**이며, C언어 자체가 내장하고 있는 라이브러리 입니다. 즉, 어떠한 개인이 만든 라이브러리가 아니라 C언어가 기본적으로 제공하는 라이브러리 라는 뜻이죠.

이처럼 표준 라이브러리의 헤더 파일을 포함하는 경우는 헤더 파일의 이름을 `<>` 로 감쌉니다. 그러나 개인이 만든 사용자 라이브러리의 경우 헤더 파일의 이름을 `""` 로 감싸죠.

아래 코드를 통해 차이를 확인해 보시기 바랍니다.

```c
#include <stdio.h>
#include <string.h>
#include "CustomVector.h"
#include "My_IO.h"
```

 위의 두 헤더는 `<>`로 감싸져 있으므로 C 표준 라이브러리임을 알 수 있으며, 아래 두 헤더는 `""`로 감싸져 있으므로 어떠한 개인 사용자가 편의를 위해 직접 만든 라이브러리임을 알 수 있습니다.

헤더와 소스 파일 등에 대한 자세한 내용은 추후에 **분할 컴파일**에 대해 배우게 되면 알 수 있습니다.

## 2. 표준 문자열 라이브러리

이렇듯 C언어에서는 언어 자체에서 프로그램의 이식성과 프로그래머 편의를 보장하기 위해 다양한 표준 라이브러리들을 제공해 줍니다.

그 중 문자열(문자 배열)을 다양하게 활용할 수 있는 함수들을 구현해 모아 놓은 **표준 문자열 라이브러리**도 존재합니다.

표준 문자열 라이브러리의 헤더 파일은 다음과 같이 포함시킬 수 있습니다.

```c
#include <string.h>
```

헤더의 이름부터가 **문자열**을 의미하는 **string**이니 까먹지 않고 사용할 수 있을 것입니다.

string 표준 라이브러리에는 매우 다양한 함수들이 존재하지만, 이번 페이지에서는 대표 함수 몇 가지만을 소개할 것이며, 다음과 같습니다.

*   strcpy - 문자열을 복사해 주는 함수
*   strlen - 문자열의 진짜 길이(널 문자를 제외한 길이)를 반환하는 함수
*   strcmp - 두 문자열이 같은지, 같지 않은지, 같지 않다면 어떤 문자열이 더 큰지(사전 순서로 더 뒤에 오는지) 알려주는 함수
*   strcat - 두 문자열을 서로 접합해(이어 붙여) 주는 함수

## 3. strcpy - 문자열의 복사

**문자열을 문자 배열에 복사**해 주는 **strcpy(string copy) 함수**는 다음과 같은 형태를 가집니다.

```c
char* strcpy(char* dest, const char* source);
```

아직 함수와 포인터를 배우지 않아 알아보기 어려울 수 있으나, 간단히 설명하자면

*   첫 번째 매개변수에 문자열을 복사받을 **배열의 주소**를 전달하고
*   두 번째 매개변수에 배열에 복사해줄 **문자열(또는 문자열 리터럴)** 을 전달하면
*   배열에 문자열을 복사해준 후 그 **배열의 주소**를 반환합니다.

우리는 앞서 다음과 같은 코드가 불가능하다고 했습니다.

```c
char arr[6];

arr = "Hello";
```

arr도 배열의 시작 주소이고, "Hello"도 문자열의 시작 주소이므로 주소에 주소를 넣을 수 없기 때문이었죠.

그런데 strcpy 함수를 이용하면 다음과 같이 사용이 가능합니다.

```c
char arr[6];

strcpy(arr, "Hello");

printf("%s", arr);
```

위 코드는 다음과 같이 정상적으로 출력됩니다.

```c
Hello
```

## 4. strlen - 문자열의 길이

문자열은 배열이므로 해당 배열의 길이(byte 크기가 아니라 말 그대로 원소 개수)를 알기 위해선 다음과 같이 sizeof 연산자를 사용해야 했습니다.

```c
char arr[] = "Hello Guys!";

size_t length = sizeof(arr)/sizeof(char);
```

그런데 이렇게 길이를 구해도 정확한 문자열의 길이가 나오지 않습니다. 항상 실제 길이보다 1 증가되어 나오게 되죠(왜 그런지 바로 알아차리지 못했다면 문자열부터 다시 읽고 오셔야 합니다!)

또 무엇보다도, **다른 함수에 전달된 배열에는 sizeof연산자를 정상적으로 쓸 수 없다**는 단점이 있습니다.

**strlen(string length) 함수**는 정확한 문자열의 길이를 알려줄 뿐만 아니라 다른 함수에서도 문자열의 길이를 구할 수 있도록 도와줍니다.

**strlen** 함수는 다음과 같은 형태를 가집니다.

```c
size_t strlen(const char* str);
```

형태를 설명하면 다음과 같습니다.

*   문자 배열(또는 문자열 리터럴)을 매개변수로 전달하면
*   해당 문자열의 길이를 **size_t(unsigned int)** 형태로 반환합니다.

따라서 다음과 같이 사용합니다.

```c
char arr[] = "Hello Guys!";

printf("Hello Guys! 의 길이 : %d\n", strlen(arr));
printf("Bye~ 의 길이 : %d", strlen("Bye~"));
```

위 코드는 다음과 같이 출력됩니다.

```text
Hello Guys! 의 길이 : 11
Bye~ 의 길이 : 4
```

## 5. strcmp - 문자열의 비교

지금까지 코딩을 하다 보면 이런 코드를 작성해 본 경험이 있는 분도 있을 것입니다.

```c
char arr[32];

scanf("%s", arr);

if(arr == "Hello")
{
	//Say Greeting
}
else if(arr == "Bye")
{
	//...
}
//...
```

그런데 우리는 이제 **문자열과 배열의 이름이 주소**라는 걸 알았으니 위 코드가 잘못되었음을 알 수 있습니다.

**arr이라는 배열은 RAM의 임의의 위치에 들어 있을 것이고, "Hello"나 "Bye"라는 문자열은 ROM의 임의의 위치에 들어 있을 테니 절대 같을 수 없겠죠?**

그렇다면 두 문자열이 같은 문자열인지(같은 문자들로 구성되어 있는지) 파악하려면 어떻게 해야 할까요?

바로 표준 문자열 라이브러리의 **strcmp(string compare) 함수**를 이용합니다. 

strcmp 함수는 다음과 같은 형태로 정의되어 있습니다.

```c
int strcmp(const char* str1, const char* str2);
```

형태를 설명하면 다음과 같습니다.

*   서로 같은지 그렇지 않은지 비교할 두 문자열을 매개변수에 넣어 줍니다.
*   두 문자열이 완전히 같다면 **정수 0**을, 왼쪽 문자열이 더 작다면(사전 순으로 앞에 온다면) **정수 -1**을, 그렇지 않으면 **정수 1**을 반환합니다.

그러므로 위의 코드는 아래와 같이 사용해야 합니다.

```c
char arr[32];

scanf("%s", arr);

if(strcmp(arr,"Hello") == 0)
{
    // Say Greeting
}
else if(strcmp(arr,"Bye") == 0)
{
    //...
}
//...
```

문자열의 크기 비교는 아래 과정을 거칩니다.

1.  두 문자열의 가장 처음에 위치한 문자부터 각각 비교한다.
2.  둘 중 한 문자열의 끝에 도달할 때까지 비교하되 도중에 아스키 코드의 값이 다른 문자가 비교되면 비교를 종료하고 비교 결과를 반환한다.
3.  둘 중 한 문자열의 끝에 도달하면 비교를 종료한다.
4.  두 문자열 모두 끝에 도달했다면 0을, 그렇지 않다면 비교 결과를 반환한다.

쉽게 얘기해서, **1순위로 알파벳 순서(아스키 코드의 값)를, 2순위로 문자열의 길이를 확인**한다는 뜻입니다.

따라서, 다음과 같은 코드가 있다면

```c
char a[] = "abc";
char b[] = "z";
char c[] = "abcd";

strcmp(a, b) > 0 ? printf("abc가 z보다 크다.\n") : printf("z가 abc보다 크다.\n");
strcmp(a, c) > 0 ? printf("abc가 abd보다 크다.") : printf("abd가 abc보다 크다.");
```

다음과 같은 출력 결과가 나타납니다.

```text
z가 abc보다 크다
abcd가 abc보다 크다.
```

**abc와 z의 비교에서** z는 a보다 더 사전순으로 뒤에 오기 때문에 크기가 큰 것으로 간주되어 비교를 종료하고 결과를 반환합니다.

**abc와 abcd의 비교에서** abcd는 abc까지는 abc와 문자 구성은 동일하나 그 외에 문자가 더 포함되어 있어 길이가 길기 때문에 크기가 큰 것으로 간주되에 비교를 종료하고 결과를 반환합니다.

## 6. strcat - 문자열의 연결

만약에 **"Hello" 라는 문자열과 " World!" 라는 두 문자열이 있을 때, 이 둘을 합치고 싶다면** 어떻게 해야 할까요?

이처럼 두 문자열을 이어붙인 문자열을 만들고 싶을 때 **strcat(string concatenate) 함수**를 이용합니다.

**strcat 함수**는 다음처럼 정의되어 있습니다.

```c
char* strcat(char* dest, const char* source);
```

형태를 설명하면 다음과 같습니다.

*   첫 번째 매개변수로 몸체가 될 **문자 배열의 주소**를 전달합니다.
*   두 번째 매개변수로 몸체 문자열에 **이어 붙일 문자 배열(또는 문자열 리터럴)**의 주소를 전달합니다.
*   함수 내부에서 문자열을 붙인 후 이어붙인 문자열의 주소를 반환합니다.

따라서 다음과 같이 사용합니다.

```c
char greet[64] = "Hello";
char world[] = " World!";

strcat(greet, world);
printf("%s\n", greet);

strcat(greet, " Nice to meet you!");
printf(greet);
```

다음과 같은 결과가 나타납니다.

```text
Hello World!
Hello World! Nice to meet you!
```

이 때 주의해야 할 점이 있습니다. strcat은 원래 배열에 문자열을 추가로 이어 붙이는 것이기 때문에 문자 배열의 크기가 넉넉하지 않다면 이어 붙이는 도중 **인덱스 유효 범위를 넘어가 에러가 발생**하게 됩니다!

----

*(C) 2021. Im-Yongsik(Hamsik2rang) all rights reserved.*

<div style="text-align:left"> <a href="./4.문자열_배열.md">← 문자열 배열</a><div/>
<div style="text-align:right"> <a href="">마지막 페이지</a><div/>








