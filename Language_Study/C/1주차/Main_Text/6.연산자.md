# C 학습 1주차

## 목차

1.  **개요**
    1.  프로그램과 프로그래밍 언어
    2.  프로그래밍 언어의 분류
    
2.  **C 기본 구조**
    1.  C의 장점과 단점
    2.  C의 구성 요소
    3.  C의 기본 형식
    4.  C의 기본 입출력 방법
    5.  주석
    
3.  **C 프로그램 생성 원리**
    
    1.  실행 파일 생성 과정
    
4.  **자료형(Data Type)**
    1.  메모리(Memory)란?
    2.  컴퓨터의 양수/음수 구별 방법
    3.  컴퓨터의 정수/문자 구별 방법
        1.  ASCII Code란?
    4.  컴퓨터의 실수 표현 방법
    5.  자료형의 종류
        1.  정수 자료형(Integer Type)
            1.  오버플로우(Overflow)와 언더플로우(Underflow)
        2.  문자 자료형(Character Type)
        3.  실수 자료형(Floating Point Type)

    6.  자료형의 크기를 알 수 있는 sizeof 연산자

5.  **상수와 변수(Constant & Variable)**

    1.  상수와 변수의 차이
    2.  상수
        1.  진법 기초
        2.  리터럴 상수(Literal)
            1.  정수 리터럴
            2.  문자 리터럴
            3.  실수 리터럴
            4.  문자열 리터럴
        3.  매크로 상수
        4.  const 변수
    3.  변수
        1.  변수의 이름 - 식별자(Identifier)
        2.  변수 선언과 초기화
        3.  변수의 사용 방법

6.  **연산자(Operator)**
    1.  표현식이란?
    2.  연산자와 피연산자
    3.  전체 연산자 둘러보기
        1.  피연산자의 개수에 따라
        2.  연산자의 기능에 따라
    4.  연산자의 종류
        1.  대입 연산자(Assignment Operator)
        2.  산술 연산자(Arithmetic Operator)
        3.  증감 연산자(Increment/Decrement Operator)
        4.  관계 연산자(Relational Operator)
        5.  논리 연산자(Logical Operator)
        6.  비트 연산자(Bitwise Operator)
        7.  복합 대입 연산자(Additional Assignment Operator)
        8.  조건 연산자(Conditional Operator)
        9.  그 밖의 연산자들
    5.  연산자 우선순위와 연산 방향
        1.  연산자 우선순위
        2.  연산 방향

7.  **알고 계셨나요?🤓(부록)**
    1.  2021년 가장 많이 사용되는 프로그래밍 언어 Top 10.
    2.  컴퓨터의 기본 자료 저장 단위
    3.  컴퓨터에서 음수를 표현하는 세 가지 방법
    4.  부동 소수 표기법
    5.  다양한 코딩 스타일과 코드 컨벤션(Code Convention)

---

## 6. 연산자(Operator)

### 6.1. 표현식이란?

C 관련해서 모르는 점이 있을 때 구글로 검색을 하다 보면 **'expression'** 이라는 영단어를 자주 보게 됩니다.

**표현식(Expression)** 이란 하나 이상의 연산자를 포함한 **문장(Statement)** 입니다.

간단히 예를 들어 살펴봅시다.

```c
int a = 3;			// 연산자 '='가 들어있으므로 표현식
int b = a + 3;		// 연산자 '=', '+'가 들어있으므로 표현식

printf("%d", b);	// 어떠한 연산자도 들어있지 않으므로 표현식이 아님
```

앞으로 어떠한 연산을 하는 문장이 있다면, 그 문장을 표현식이라는 용어로 부르겠습니다.

----

### 6.2. 연산자와 피연산자

앞서 표현식에는 하나 이상의 **연산자**가 포함된다고 했습니다.

그렇다면 연산자란 무엇일까요?

**연산자(Operator)** 란 **하나 이상의 값을 정해진 기능(규칙)에 따라 변형해주는 요소**입니다. 이 때 **정해진 규칙**은 각 연산자마다 다르게 설정되어 있습니다.

이렇게 사전적 정의를 하지 않아도 직관적으로 연산자가 무엇인지 이해하실 것입니다.

```c
-a;
a + 3;
c = b * a;
c / 7;
a % 3;

a++;
b-=1;
a>b ? c : c - 1;
a, b, c
```

위 코드에 a, b, c, 상수, 그리고 세미콜론을 제외한 모든 기호가 바로 연산자입니다.

그리고 이 연산자를 통해 변형시킬 값을 **피연산자(Operand)** 라고 합니다.

연산자는 하나 이상의 피연산자를 가지게 되고, 연산자마다 필요로 하는 피연산자가 다르기 때문에 보통 연산자를 구분할 때에는 **연산자의 기능** 또는 피연산자의 개수에 따라 구분합니다.

----

### 6.3. 전체 연산자 둘러보기

#### 1. 연산자의 기능에 따라

| 분류             | 연산자                             | 기능                                                         |
| ---------------- | ---------------------------------- | ------------------------------------------------------------ |
| 대입 연산자      | =                                  | 오른쪽 피연산자의 값을 왼쪽에 복사해 대입 후 평가            |
| 산술 연산자      | +  -  *  /  %                      | 양 옆의 두 피연산자의 값을 평가                              |
| 증감 연산자      | ++  --                             | 피연산자의 값을 1 증가 또는 감소                             |
| 관계 연산자      | > < >= <= == !=                    | 두 피연산자를 비교해 논리값(참/거짓)을 평가                  |
| 논리 연산자      | &&  \|\|  !                        | 피연산자(들)의 논리값에 따라 표현식 전체의 논리값(참/거짓)을 평가 |
| 비트 연산자      | & \| ^ ~ << >>                     | 피연산자(들)을 비트 크기 차원에서 평가                       |
| 복합 대입 연산자 | += -= *= /= %= &= \|= <<= >>= ^=   | 오른쪽 피연산자의 값을 연산자에 따라 왼쪽 변수에 연산해 적용 후 평가 |
| 조건 연산자      | ?:                                 | 논리값에 따라 다른 결과를 평가                               |
| 그 밖의 연산자   | .  ,  sizeof  형변환  []  ->  *  & |                                                              |

#### 2. 피연산자의 개수에 따라

| 분류        | 의미                    | 연산자                                                       |
| ----------- | ----------------------- | ------------------------------------------------------------ |
| 단항 연산자 | 피연산자가 한 개인 경우 | +, -, ++, --, &, ~, !, sizeof, 형변환, *, &, []              |
| 이항 연산자 | 피연산자가 두 개인 경우 | +, -, *, /, %, =, >, <, <=, >=, !=, &&, \|\|, &, \|, ^, <<, >>, +=, -=, *=, /=, %=, <<=, >>=, %=, \|=, ^=, ,, ->, . |
| 삼항 연산자 | 피연산자가 세 개인 경우 | ?:                                                           |

굉장히 많지만 프로그래밍을 자주 하다 보면 자연스레 손에 익어서 외워지게 되니 일부러 외울 필요는 없습니다.

----

### 6.4.  연산자의 종류

#### 1. 대입 연산자(Assignment Operator)

대입 연산자란, 오른쪽 피연산자의 값을 복사해 왼쪽에 대입 후 평가하는 연산자입니다.

```c
a = 3;
```

이 때 3이라는 값이 **복사되어** 왼쪽의 a에게 전달됩니다.

왼쪽 피연산자는 값을 전달받으므로 값의 저장이 가능한 **변수(거나 초기화되려는 const변수)** 여야 합니다.

다음과 같은 표현식은 올바르지 않습니다.

```c
4 = 3
```

4라는 정수 리터럴은 *물론 임시변수가 할당되어 있긴 하지만* 값을 저장할 수 없으므로 이 경우 에러가 나게 됩니다.

하나의 연산자 기호는 최대 양 옆에 두 개의 피연산자를 가지므로(삼항연산자는 두 개의 기호를 사용하므로 각각의 기호를 기준으로는 피연산자가 두 개입니다) 일반적으로 연산자의 **왼쪽 피연산자**를 **l-value(left value)** , **오른쪽 피연산자**를 **r-value(right value)** 라고 부릅니다.

따라서 대입 연산자의 경우 **l-value가 변수여야 합니다.**

#### 2. 산술 연산자(Arithmetic Operator)

**산술 연산자(Arithmetic Operator)** 는 이름 그대로 산술연산(사칙연산)을 수행하는 연산자이며, 다음과 같은 종류가 존재합니다.

| 기호 | 이름                         | 의미                                            |
| ---- | ---------------------------- | ----------------------------------------------- |
| +    | 덧셈 연산자                  | 덧셈을 수행한 후 그 값을 평가한다               |
| -    | 뺄셈 연산자                  | 뺄셈을 수행한 후 그 값을 평가한다               |
| *    | 곱셈 연산자                  | 곱셈을 수행한 후 그 값을 평가한다               |
| /    | 몫 연산자                    | 나눗셈을 수행한 후 그 결과의 몫을 평가한다      |
| %    | 나머지 연산자(모듈로 연산자) | 나눗셈을 수행항 후 그 결과의 나머지를 평가한다. |

아까부터 등장한 **평가(Evaluate)** 라는 용어는 무슨 뜻일까요?

**평가**란, 연산자가 연산을 수행한 후 그 결과를 **반환**한다는 뜻입니다.

예를 들어 대입 연산자는 r-value를 l-value에 복사해 전달한 후 그 값을 반환합니다. 따라서 이런 코드가 허용됩니다.

```c
int a = 3;
int b = 2;
int c = b = a;

printf("%d", c);
```

세 번째 줄의 코드에서, b = a라는 연산이 수행된 후 그 결과인 3이 **평가(반환)** 됩니다. 그리고 이 값과 변수 c가 또 대입 연산자에 의해 대입 연산이 수행되므로 c에도 3이 복사된 후 그 값이 평가되죠.

따라서 위 코드를 실행하면 3이 출력됩니다.

일반적으로 연산자들은 각각의 연산 결과를 출력합니다(심지어 **컴마`,`연산자**마저도 그 결과를 평가합니다!)

마찬가지로, 모든 산술 연산자들은 값을 평가하므로 산술 연산을 수행하는 표현식을 대입 연산자를 통해 변수에 대입할 수 있습니다.

장황하게 쓰여 있지만 다음과 같은 코드가 가능하다는 뜻입니다.

```c
int a = 3 - 2 * 4;
```

#### 3. 증감 연산자(Increment/Decrement Operator)

**증감 연산자(Incrememt/Decrememt Operator)** 란 단항 연산자로서 피연산자의 값을 1 증가/감소시키는 연산자입니다. 다만 산술 연산자와 달리 피연산자는 반드시 변수여야 합니다. 1 증가/감소시킨 값을 다시 저장해야 하기 때문이죠.

증감 연산자는 다음과 같습니다.

| 기호 | 이름        | 의미                            |
| ---- | ----------- | ------------------------------- |
| ++   | 증가 연산자 | 피연산자의 값을 1 증가시킵니다. |
| --   | 감소 연산자 | 피연산자의 값을 1 감소시킵니다. |

단순히 보기엔 굉장히 간단한 연산자 같지만, 프로그래밍을 처음 배우는 분들에게 매우 이해하기 어려운 연산자입니다. 왜냐하면 **증감 연산자는 피연산자의 앞에 붙을 수도 있고, 뒤에 붙을 수도 있는데 어디에 붙었냐에 따라 평가 결과가 달라지기 때문**입니다.

피연산자의 앞에 붙는 증감연산자를 **전위 증감 연산자(Prefix In/Dec Operator)** 라 합니다.

피연산자의 뒤에 붙는 증감연산자를 **후위 증감 연산자(Postfix In/Dec Operator)** 라 합니다.

표로 정리하면 다음과 같습니다.

| 기호       | 이름             | 의미                                             |
| ---------- | ---------------- | ------------------------------------------------ |
| ++피연산자 | 전위 증가 연산자 | 피연산자의 값을 1 증가시키고 그 값을 평가합니다. |
| --피연산자 | 전위 감소 연산자 | 피연산자의 값을 1 감소시키고 그 값을 평가합니다. |
| 피연산자++ | 후위 증가 연산자 | 피연산자의 값을 평가한 후 값을 1 증가시킵니다.   |
| 피연산자-- | 후위 증가 연산자 | 피연산자의 값을 평가한 후 값을 1 감소시킵니다.   |

예제 코드를 통해 확인해 보겠습니다.

```c
int a = 3;
int b = 3;

int c = ++a;
int d = b++;

printf("c is %d, d is %d", c, d);
```

위 코드의 결과를 한번 예측해 보시기 바랍니다.

결과는 다음과 같습니다.

```c
c is 4, d is 3
```

a와 b에 같은 값을 대입한 후 c와 d에 각각 a와 b에 증가 연산을 수행한 뒤 평가된 값을 대입했습니다.

그런데 c는 4이고 d는 3이 대입되었죠.

왜냐하면 전위 연산은 연산 후 평가를 진행하고, 후위 연산은 평가 후 연산을 진행하기 때문입니다.

여기까지 이해가 되셨다면 다음은 표현식 안에서 전위 연산과 후위 연산의 차이를 살펴보겠습니다.

```c
int a = 4;
int b = 3;

int c = 5 + ++a - b++;

printf("c is %d, a is %d, and b is %d", c, a, b);
```

위 코드의 결과를 한 번 스스로 생각해 본 뒤, 결과를 확인해 보시기 바랍니다.

결과는 다음과 같습니다.

```c
c is 7, a is 5, and b is 4
```

전위 연산은 연산을 수행 후 그 값을 평가하므로 위 코드에서 a는 1이 증가된 상태로 표현식에 포함됩니다.

그러나 후위 연산은 값을 평가 후 연산을 수행하므로 b는 표현식에 원래 값을 평가(제공)한 후 자신의 값을 증가시킵니다.

여기까지 정확히 이해하셨다면 전위 연산과 후위 연산의 마지막 차이를 살펴보겠습니다.

두 연산의 또 다른 차이점은 **후위 연산은 중복 연산이 불가능하다**입니다.

예를 들어, 전위 연산은 다음과 같은 연산 형태가 허용됩니다.

```c
int a = 3;
++++a;

int b = 4;
------b;

int c = 5;
--++c;
```

여기서 각각의 연산은 다음과 같은 의미입니다.

```c
++(++a);
--(--(--b));
--(++c);
```

그러나 후위 연산은 먼저 평가한 후 연산을 진행하는데, 후위 연산 여러개가 중복 적용될 경우 그 평가 결과를 예측할 수 없으므로 문법적으로 허용하지 않습니다.

즉, 아래와 같은 연산은 불가능합니다.

```c
int a = 4;
a++++;
```

또, 후위 연산과 전위 연산은 함께 사용할 수 없습니다. 따라서 아래와 같은 연산은 불가능합니다.

```c
int a = 5;
++a++;
```

여기까지 이해하셨다면 증감연산자의 사용법에 대해 완벽하게 이해한 것입니다. 축하합니다!

#### 4. 관계 연산자(Relational Operator)

**관계 연산자(Relational Operator)** 는 두 피연산자 사이의 비교를 수행하고 그 결과를 참/거짓으로 평가하는 연산자입니다.

관계 연산자는 다음과 같습니다.

| 기호 | 이름                    | 의미                                                         |
| ---- | ----------------------- | ------------------------------------------------------------ |
| ==   | 같음 연산자             | 양쪽의 피연산자가 같은 값이라면 참(1)을, 다르다면 거짓(0)을 평가합니다. |
| !=   | 같지 않음 연산자        | 양쪽의 피연산자가 다른 값이라면 참(1)을, 같다면 거짓(0)을 평가합니다. |
| >    | 보다 큼 연산자          | l-value가 r-value보다 크면 참(1)을, 그렇지 않다면 거짓(0)을 평가합니다. |
| <    | 보다 작음 연산자        | l-value가 r-value보다 작으면 참(1)을, 그렇지 않다면 거짓(0)을 평가합니다. |
| >=   | 보다 크거나 같음 연산자 | l-value가 r-value보다 크거나 같으면 참(1)을, 그렇지 않다면 거짓(0)을 평가합니다. |
| <=   | 보다 작거나 같음 연산자 | l-value가 r-value보다 작거나 같으면 참(1)을, 그렇지 않다면 거짓(0)을 평가합니다. |

기호의 형태에서 알 수 있듯이 수학의 등호, 부등호와 동일한 역할을 수행하는 연산자이나, 두 가지 주의해야 할 사항이 있습니다.

* 첫 번째로, 같음 연산자는 `=`가 두 개 연속으로 붙어 있는 형태라는 점입니다. **대입 연산자와 같음 연산자를 헷갈리지 않도록 조심해야 합니다.**

*   C에서 **거짓(False)은 0으로 표현**되며, **0이 아닌 값은 모두 참(True)** 으로 표현됩니다.

둘 다 지금은 중요성이 크게 와닿지 않으나, 나중에 **조건문**에 대해 배우게 될 때 반드시 숙지해야 하는 내용입니다.

그 외에는 어려운 부분이 없으므로 간단히 코드로 살펴보고 넘어가겠습니다.

```c
int a = 3 == 4;
int b = 0 != 1;

int c = a < b;

printf("%d = %d < %d", c, a, b);
```

출력 결과는 다음과 같습니다.

```c
1 = 0 < 1
```

#### 5. 논리 연산자(Logical Operator)

**논리 연산자(Logical Operator)** 는 피연산자들의 참/거짓에 따른 결과를 평가하는 연산자입니다.

논리 연산자는 다음과 같습니다.

| 기호 | 이름       |                            의미                            |
| :--: | :--------- | :--------------------------------------------------------: |
| \|\| | OR 연산자  | 두 피연산자 중 하나라도 참이면 참, 그렇지 않으면 거짓 평가 |
|  &&  | AND 연산자 |    두 피연산자 모두 참이면 참, 그렇지 않으면 거짓 평가     |
|  !   | NOT 연산자 |          피연산자가 참이면 거짓, 거짓이면 참 평가          |

NOT 연산자는 단항 연산자(피연산자가 하나)이며, AND연산자와 OR연산자는 이항 연산자(피연산자가 둘)입니다.

간단히 코드로 살펴보겠습니다.

```c#
int a = 1;
int b = 0;
int c = -3;
int d = 0;

int x = a || b;		// true(1) || false(0) = true(1)
int y = a && b;		// true(1) && false(0) = false(0)
int z = a && c;		// true(1) && true(-3) = true(1)
int w = b || d;		//	false(0) || falseI(0) = false(0)

int notX = !x;		// not true = false(0)
int notY = !y;		// not false = true(1)
```

논리 연산자는 단독적으로 사용하기보다는 조건문과 함께 사용하는 경우가 많지만, 논리 연산자의 연산 과정을 자세히 알면 논리 연산자만으로 조건문을 구현할 수 있습니다.

모든 논리 연산자는 왼쪽 피연산자의 값을 먼저 확인한 후 오른쪽 피연산자의 값을 확인합니다. 그러므로

**AND연산의 경우 하나라도 false라면 바로 false를 평가하기 때문에 왼쪽 피연산자가 false라면 오른쪽 피연산자는 값을 확인하지 않습니다.**

**OR연산의 경우 하나라도 true면 바로 true를 평가하기 때문에 왼쪽 피연산자가 ture라면 오른쪽 피연산자는 값을 확인하지 않습니다.**

이를 반대로 생각하면

**AND연산자는 왼쪽이 true라면 오른쪽을 반드시 확인해 보아야 합니다.**

**OR연산자는 왼쪽이 false라면 오른쪽을 반드시 확인해 보아야 합니다.**

따라서 이런 코드가 가능합니다.

```c#
int a = 3;
int b = 4;

(a > 2) && b++;
(a > 4) && b++;
```

위 코드에서 a는 2보다 크기 때문에 첫 번째 AND연산은 b++이라는 코드를 실행합니다.

그러나 a는 4보다는 작으므로 두 번째 AND연산의 b++은 실행하지 않습니다.

따라서 위 코드의 결과는 b의 값이 5가 됩니다.

이 과정이 이해되신다면 한번 다음 코드의 결과를 예측해 보시기 바랍니다.

```c#
int a = 0;
int b = 5;

a || b--;
a++ && b--;
a && b--;
a++ || b--;

printf("a is %d, and b is %d", a, b);
```

답은 직접 코드를 작성해 확인해 보세요!

----

#### 6. 비트 연산자(Bitwise Operator)

**비트 연산자(Bitwise Operator)** 는 **비트 단위의 연산을 위한 연산자**입니다.

컴퓨터 안의 데이터는 비트 단위로 저장되지만 **운영체제는 바이트 단위로 주소를 관리하기 때문에 비트 하나하나를 세부적으로 수정하기 위해선 반드시 비트 연산을 사용해야만 합니다.**

비트 연산자는 다음과 같습니다.

| 기호 | 이름               | 의미                                                         |
| :--: | ------------------ | ------------------------------------------------------------ |
|  \|  | 비트 OR 연산자     | 두 값의 자릿수가 같은 각 비트를 비교해 하나라도 1이면 1, 그렇지 않으면 0으로 비트를 채운 결과를 평가합니다. |
|  &   | 비트 AND 연산자    | 두 값의 자릿수가 같은 각 비트를 비교해 둘 다 1이면 1, 그렇지 않으면 0으로 비트를 채운 결과를 평가합니다. |
|  ^   | 비트 XOR 연산자    | 두 값의 자릿수가 같은 각 비트를 비교해 두 비트가 서로 다른 값이면 1, 그렇지 않으면 0으로 비트를 채운 결과를 평가합니다. |
|  ~   | 비트 NOT 연산자    | 피연산자의 비트를 전체 반전시킨 후 그 값을 평가합니다.       |
|  >>  | 우측 시프트 연산자 | l-value의 모든 비트를 r-value만큼 오른쪽으로 자리이동 한 결과를 평가합니다. |
|  <<  | 좌측 시프트 연산자 | l-value의 모든 비트를 r-value만큼 왼쪽으로 자리이동 한 결과를 평가합니다. |

각 비트 연산을 이미지로 확인해 보겠습니다.

*   **비트 OR 연산자**

    ![](../Images/bitwise_or.png)



*   **비트 AND 연산자**

    ![](../Images/bitwise_and.png)



*   **비트 XOR 연산자**

    ![](../Images/bitwise_xor.png)



*   **비트 NOT 연산자**

    ![](../Images/bitwise_not.png)



*   **좌측 시프트 연산자**

    ![](../Images/bitwise_left_shift.png)



*   **우측 시프트 연산자**

    ![](../Images/bitwise_right_shift.png)

위 그림은 1바이트 크기의 데이터들을 기준으로 비트연산을 수행한 결과를 나타낸 것입니다.

이 중 시프트 연산의 경우, **좌측으로 밀거나 우측으로 밀었을 때 새로 생기는 비트는 모두 0값을 가진다는 것**에 주의하세요.

위 그림만으로 비트 연산을 이해하신 분들도 있겠지만, 일반적으로 비트 연산자는 상당히 이해하기 어려운 연산자입니다. 그러니 그림으로 이해가 어려우시다면 부담 가지지 말고 언제든지 개인적으로 질문해주세요!

---

#### 7. 복합 대입 연산자(Additional Assignment Operator)

**복합 대입 연산자(Additional Assignment Operator)** 는 몇몇 연산자가 할당 연산자와 결합된 형태를 띕니다. 그리고 그 기능 역시 두 연산자가 결합된 것 처럼 기능합니다.

복합 대입 연산자는 다음과 같습니다.

| 기호 | 이름                    | 의미                                                         |
| :--: | ----------------------- | ------------------------------------------------------------ |
|  +=  | 덧셈 대입 연산자        | l-value의 값을 r-value에 더한 후 그 결과를 l-value에 대입합니다. |
|  -=  | 뺄셈 대입 연산          | l-value의 값을 r-value에서 뺀 후 그 결과를 l-value에 대입합니다. |
|  *=  | 곱셈 대입 연산자        | l-value의 값을 r-value에 곱한 후 그 결과를 l-value에 대입합니다. |
|  /=  | 몫 대입 연산자          | l-value의 값을 r-value로 나눈 몫을 l-value에 대입합니다.     |
|  %=  | 나머지 대입 연산자      | l-value의 값을 r-value로 나눈 나머지를 l-value에 대입합니다. |
| \|=  | 비트 OR 대입 연산자     | l-value와 r-value를 비트 OR 연산한 후 그 결과를 l-value에 대입합니다. |
|  &=  | 비트 AND 대입 연산자    | l-value와 r-value를 비트 AND 연산한 후 그 결과를 l-value에 대입합니다. |
|  ^=  | 비트 XOR 대입 연산자    | l-value와 r-value를 비트 XOR 연산한 후 그 결과를 l-value에 대입합니다. |
| <<=  | 좌측 시프트 대입 연산자 | l-value를 r-value만큼 좌측 시프트 연산한 후 그 결과를 l-value에 대입합니다. |
| >>=  | 우측 시프트 대입 연산자 | l-value를 r-value만큼 우측 시프트 연산한 후 그 결과를 l-value에 대입합니다. |

복합 대입 연산자는 다음 코드를 보면 매우 직관적으로 이해할 수 있습니다.

```c#
int a = 3;

a += 2;
a -= 2;
a *= 2;
a /= 2;
a %= 2;
a |= 2;
a &= 2;
a ^= 2;
a <<= 2;
a >>= 2;
//////////////////////////////////////
//위 코드는 아래 코드와 완전히 동치입니다.//
//////////////////////////////////////
a = a + 2;
a = a - 2;
a = a * 2;
a = a / 2;
a = a % 2;
a = a | 2;
a = a & 2;
a = a ^ 2;
a = a << 2;
a = a >> 2;
```

----

#### 8. 조건 연산자(Conditional Operator)

**조건 연산자(Conditional Operator)** 는 연산자 중 유일한 **삼항 연산자(Tenary Operator - 피연산자가 세 개)** 이기 때문에 삼항 연산자라고 부르기도 합니다.

조건 연산자는 다음과 같습니다.

| 기호 | 이름        | 의미                                                         |
| ---- | ----------- | ------------------------------------------------------------ |
| ?:   | 관계 연산자 | 왼쪽 표현식(피연산자)의 결과가 참이라면 중간 표현식(피연산자)를, 그렇지 않다면 마지막 표현식(피연산자)를 반환합니다. |

즉, 다음과 같습니다.

```c#
표현식?표현식이_true일때_리턴할_값:표현식이_false일때_리턴할_값;
```

예시 코드로 살펴보겠습니다.

``` C#
int a = 3;

int b = a > 2 ? 4 : 1;				// b = 4
char c = a > 5 ? 'O' : 'X';			// c = 'X'
```

a는 2보다 크므로 조건 연산자는 **중간에 위치한 피연산자인 4를 평가**합니다. 따라서 b에는 4가 대입됩니다.

그러나 a는 5보다는 작으므로 조건 연산자는 **마지막에 위치한 피연산자인 'X'를 평가**합니다. 따라서 c에는 'X'가 대입됩니다.

다음 코드는 실제 조건 연산자를 사용하는 예시입니다.

```c
#include <stdio.h>

int main()
{	
    int a = 3, b = 5, c = 2;
    int max = a;
    int min = a;
        
    max = max < b ? b : max;
    max = max < c ? c : max;
        
    min = min > b ? b : min;
    min = min > c ? c : min;
     
    printf("최댓값 : %d", max);
    printf("최솟값 : %D", min);
     
    return 0;
}
```

출력 결과는 다음과 같습니다.

```c#
최댓값 : 5
최솟값 : 2
```

이 정도면 조건 연산자를 이해하는 데 충분하실 거라 생각합니다.

---

#### 10. 그 밖의 연산자들

그 밖에도 C에는 다양한 연산자(대표적으로 **주소 연산자 &** )가 있으나, 나머지는 지금은 사용되지 않으므로 이후에 알아보겠습니다.

## 5.5. 연산자 우선순위

한 표현식에 서로 다른 연산자들이 함께 등장하는 경우 어떤 연산부터 먼저 수행해야 할까요?

이처럼 **연산자들이 섞여 있을 때 어떤 연산부터 진행해야 하는지에 대한 규칙**이 바로 **연산자 우선순위** 입니다.

연산자 우선순위는 프로그래밍을 자주 하면서 연산 실수를 겪다 보면 알아서 외워지고, 또 숙련된 프로그래머도 헷갈리는 경우가 많으니 일부러 외우실 필요 없이 필요할 때 인터넷에서 찾아보면 됩니다. 따라서 이 페이지에도 정리하지 않겠습니다.

무엇보다 우선순위가 헷갈리신다면 간편하게 괄호`()` 연산을 사용하면 해결되기 때문입니다.

참고로, 동일한 연산자가 수식에 여러 개 존재한다면, **할당 연산자를 제외한 모든 연산자는 왼쪽->오른쪽 형태의 우선순위를 가집니다.**

----

*(C) 2021. Im-Yongsik(Hamsik2rang) all rights reserved.*

<div style="text-align:left"> <a href="./5.상수와_변수.md">← 상수와 변수</a><div/>

<div style="text-align:right"> <a href="./7.부록.md">부록 →</a><div/>
