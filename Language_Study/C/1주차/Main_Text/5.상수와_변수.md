# C 학습 1주차

## 목차

1.  **개요**
    1.  프로그램과 프로그래밍 언어
    2.  프로그래밍 언어의 분류
    
2.  **C 기본 구조**
    1.  C의 장점과 단점
    2.  C의 구성 요소
    3.  C의 기본 형식
    4.  C의 기본 입출력 방법
    5.  주석
    
3.  **C 프로그램 생성 원리**
    
    1.  실행 파일 생성 과정
    
4.  **자료형(Data Type)**
    1.  메모리(Memory)란?
    2.  컴퓨터의 양수/음수 구별 방법
    3.  컴퓨터의 정수/문자 구별 방법
        1.  ASCII Code란?
    4.  컴퓨터의 실수 표현 방법
    5.  자료형의 종류
        1.  정수 자료형(Integer Type)
            1.  오버플로우(Overflow)와 언더플로우(Underflow)
        2.  문자 자료형(Character Type)
        3.  실수 자료형(Floating Point Type)

    6.  자료형의 크기를 알 수 있는 sizeof 연산자

5.  **상수와 변수(Constant & Variable)**

    1.  상수와 변수의 차이
    2.  상수
        1.  진법 기초
        2.  리터럴 상수(Literal)
            1.  정수 리터럴
            2.  문자 리터럴
            3.  실수 리터럴
            4.  문자열 리터럴
        3.  매크로 상수
        4.  const 변수
    3.  변수
        1.  변수의 이름 - 식별자(Identifier)
        2.  변수 선언과 초기화
        3.  변수의 사용 방법

6.  **연산자(Operator)**
    1.  표현식이란?
    2.  연산자와 피연산자
    3.  전체 연산자 둘러보기
        1.  피연산자의 개수에 따라
        2.  연산자의 기능에 따라
    4.  연산자의 종류
        1.  대입 연산자(Assignment Operator)
        2.  산술 연산자(Arithmetic Operator)
        3.  증감 연산자(Increment/Decrement Operator)
        4.  관계 연산자(Relational Operator)
        5.  논리 연산자(Logical Operator)
        6.  비트 연산자(Bitwise Operator)
        7.  복합 대입 연산자(Additional Assignment Operator)
        8.  조건 연산자(Conditional Operator)
        9.  그 밖의 연산자들
    5.  연산자 우선순위와 연산 방향
        1.  연산자 우선순위
        2.  연산 방향

7.  **알고 계셨나요?🤓(부록)**
    1.  2021년 가장 많이 사용되는 프로그래밍 언어 Top 10.
    2.  컴퓨터에서 음수를 표현하는 세 가지 방법
    3.  부동 소수 표기법
    4.  다양한 코딩 스타일과 코드 컨벤션(Code Convention)

---

## 5. 상수와 변수(Constant & Variable)

### 5.1. 상수와 변수의 차이

이번 단락에서는 상수와 변수의 차이를 간단하게 설명합니다.

**상수(Constant)** 라는 용어와 **변수(Variable)** 라는 용어를 이전에 들어본 적이 있나요? 들어보았다면 어디서 들었을까요?

대부분의 사람들은 상수와 변수를 **수학 용어**로서 접했을 것입니다.
$$
y = x+3
$$
라는 수식이 있다면, 여기서 **y와 x는 변수**, **3은 상수**입니다.

y와 x는 수식을 만족하기만 한다면 값이 바뀌어도 상관이 없습니다.

x와 y의 순서쌍이 (a, b)라면

>   (1, 4)
>
>   (2, 5)
>
>   (33, 36)

처럼 **값을 항상 바꿀 수 있죠.**

그러나 **3이라는 상수는 절대 값이 변하지 않습니다.**

컴퓨터에서도 마찬가지입니다. **변할 수 있는 값**은 **변수**, **변할 수 없는 값**은 상수입니다.

### 5.2. 상수

#### 1. 진법 기초

상수에 대해 이해하기 전에 간단히 컴퓨터에서 사용하는 진법을 알아봅니다.

인간은 보통 10진법를 사용합니다. 물론 시간을 세거나 연필 개수를 셀 때에는 12진법을 사용하는 등 다양한 진법을 사용하기도 하죠.

그렇다 하더라도 여전히 인간이 가장 보편적으로 사용하는 진법은 10진법이라고 말할 수 있습니다.

그런데, 여기서 말하는 **진법(Base)** 의 정확한 의미가 무엇일까요?

N진법이란, 수 체계에 0을 포함하면서(즉 0부터 시작해서) N을 '10'으로 표기하는 수 표기 방식입니다.

**10진법**은 **0,1,2,3,4,5,6,7,8,9, 그리고 10을 '10'으로 표기**하죠.

**2진법**은 **0,1, 그리고 2를 '10'으로 표기**합니다.

그렇다면 8진법은 어떨까요?

**0,1,2,3,4,5,6,7, 그리고 8을 '10'으로 표기**합니다.

잘 사용하진 않지만 4진법이라면

**0,1,2,3, 그리고 4를 '10'으로 표기**하겠죠.

표로 4가지 진법을 한 데 모아 비교해 봅시다.

| 10진법 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |  14  |  15  |
| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 2진법  |  0   |  1   |  10  |  11  | 100  | 101  | 110  | 111  | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
| 4진법  |  0   |  1   |  2   |  3   |  10  |  11  |  12  |  13  |  20  |  21  |  22  |  23  |  30  |  31  |  32  |  33  |
| 8진법  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  10  |  11  |  12  |  13  |  14  |  15  |  16  |  17  |

이해가 되시나요? 그렇다면 마지막으로 16진법을 정의해 봅시다.

**16진법**은 **0부터 시작해서 16을 '10'으로 표현**해야 합니다.

그런데 문제가 있습니다. 16진법으로 수를 0부터 나열하면

*   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...???

**'10'을 사용하지 않고 10을 표현**해야 하는데 어떻게 해야 할까요?

16진법에서는 이를 위해 알파벳 A~F를 사용합니다. 따라서 10진수, 2진수, 8진수와 16진수를 비교하면 다음과 같습니다.

| 10진법 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
| 2진법  | 0    | 1    | 10   | 11   | 100  | 101  | 110  | 111  | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 | 10000 |
| 8진법  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 20    |
| 16진법 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | A    | B    | C    | D    | E    | F    | 10    |

**컴퓨터에서 2, 8, 16진법은 매우 자주, 그리고 중요하게 사용되므로 지금 당장이 아니더라도 언젠가는 능숙하게 변환할 수 있어야 합니다.**

#### 2. 리터럴 상수

이제 진법을 이해했으니 본격적으로 상수에 대해 알아보겠습니다.

C 에서는 **상수**를 **세 가지로 분류**합니다.

*   **리터럴 상수(Literal Constant)**
*   **매크로 상수(Macro Constant)**
*   **Const 변수**

이 중 리터럴 상수는 수학에서 볼 수 있는 일반적인 상수를 말합니다. 즉, 어떠한 변수 등에 담겨있지 않고 값 그대로 입력된 상수를 말합니다.

다음과 같은 것들이 모두 리터럴 상수입니다.

```c
3				// 정수 리터럴
3.141592		// 실수 리터럴
'A'				// 문자 리터럴
"PI"			// 문자열 리터럴
```

프로그램에서 어떠한 값을 입력하거나 사용하려면 반드시 그 값은 메모리 안에 있어야 합니다. 키보드에서 3이라는 숫자를 입력한다 하더라도 그 입력값이 바로 프로그램 내부로 들어가는 것이 아니라 일단 메모리에 저장된 후 그 메모리에서 프로그램이 값을 참조해 이용하는 것입니다.

이 때 상수가 잠시 들어가 있는 메모리 공간을 **임시 변수**라 합니다. 즉, 임시로 이름 없는 변수를 만들어 그 안에 상수를 넣은 후, 프로그램이 그 메모리에 있는 변수를 꺼내 쓰고 상수가 들어 있던 메모리는 버리는 것입니다.

따라서 리터럴 상수는 한 번 사용되고 나면 다시 사용될 수 없습니다.

또 한가지 알아두면 좋은 것은 **문자열 리터럴**의 경우 다른 리터럴 상수와 다르게 **RAM**이 아닌 **ROM**에 저장됩니다. 자세한 내용은 나중에 **동적 할당**과 함께 소개하겠습니다.

#### 3. 매크로 상수

매크로 상수는 다른 상수들과 달리 조금 다른 형태의 상수입니다.

한 가지 상황을 가정해 보겠습니다. 여러분이 **C로 게임을 제작하는데 게임 안에 들어갈 물리 엔진 코드를 작성**한다고 합시다.

물리 엔진 특성상 **중력 가속도(9.8)**와 같은 상수는 매우 빈번하게 사용되겠죠?

이처럼 **코드 내에서 빈번하게 사용**되면서도 **의미를 가진 상수**는 상수에 이름을 붙여 사용하면 편리할 것입니다.

이처럼 상수에 이름을 붙여 사용하기 위해 C 에는 매크로 상수라는 문법이 존재합니다.

매크로 상수는 다음과 같이 정의합니다.

```c
#define 매크로명 값
```

앞에 #이 붙은 걸 보고 눈치채신 분도 있겠지만, 매크로 상수는 **#define** 이라는 전처리문을 통해 정의합니다.

해당 전처리문은 컴파일러에게

>   "코드에 적힌 모든 매크로명을 지정된 값으로 대치해라"

라는 명령을 내립니다.

값의 **대입**이 아니라 **대치**라는 것을 반드시 알아 두셔야 합니다. 말 그대로 글자 자체를 치환한다는 것입니다.

예를 들어 다음과 같은 코드가 있을 때

```c
#include <stdio.h>
#define PI 3.141592

int main()
{
    double radius;
    scanf("%lf", &radius);
    
    double perimeter = 2 * PI * radius;
    
    printf("%f를 반지름으로 가진 원의 둘레는 %f입니다.\n", radius, perimeter);
    printf("원주율은 %f입니다.", PI);
    
    return 0;
}
```

컴파일러가 전처리문을 받아들이고 나면(즉 컴파일 직전에) 다음처럼 코드가 변경됩니다.

```c
// ...stdio.h 안의 내용들이 포함됨

int main()
{
    double radius;
    scanf("%lf", &radius);
    
    double perimeter = 2 * 3.141592 * radius;
    
    printf("%f를 반지름으로 가진 원의 둘레는 %f입니다.", radius, perimeter);
    printf("원주율은 %f입니다.", 3.141592);
    
    return 0;
}
```

코드 안의 모든 `PI`가 `3.141592`로 변환된 것이 보이시나요? 

이처럼 #define은 문자열을 원하는 값으로 대치하므로 **문자열 대치 전처리문**이라고 하기도 합니다.

혹시나 #define의 작동 방식이 애매모호한 분들을 위해 재미있는 코드를 하나 작성해 보겠습니다.

```c
#include <stdio.h>
#define MACRO_GREETING printf("반갑습니다\n");

int main() 
{
    MACRO_GREETING
    MACRO_GREETING
    MACRO_GREETING
        
    return 0;
}

```

위 코드를 빌드하면 다음과 같은 실행 결과가 나타납니다.

```c
반갑습니다
반갑습니다
반갑습니다
```

꼭 상수만을 치환하는 것이 아니라 **지정된 문자열을 원하는 코드로 치환**해버리는 것이 **#define 전처리문** 입니다.

참고로, **매크로 상수는 가능하면 대문자와 밑줄기호만을 이용해 표현하는 것이 좋습니다. 소문자를 이용해도 상관은 없지만 프로그래머들 사이의 관습상 소문자는 사용하지 않습니다.**

#### 4. const 변수

**리터럴 상수**는 **값을 임시 변수에 담으므로 한번 사용하고 나면 버려집니다.**

**매크로 상수** 역시 엄밀히 따지면 **문자열 형태로 사용하는 리터럴 상수**입니다. 따라서 재사용이 불가능하죠(구문의 재사용이 아니라 값의 재사용)

그렇다면, **상수가 필요하지만 이를 재사용할 수 있도록 하려면** 어떻게 해야 할까요?

C 에서는 변수 앞에 `const`라는 키워드를 붙여 변수 안의 내용이 바뀌지 않도록(변수가 상수화되도록) 강제할 수 있습니다. 그리고 이처럼 const 키워드가 붙은 변수들을 **const 변수**라 합니다.

`const`키워드는 다음처럼 사용합니다.

```c
const int a = 3;
const double e = 2.718281;
const char alpha_a = 'A';
```

const 변수를 사용할 때 주의해야 할 점은 **const 키워드는 변수를 처음 선언할 때만 사용 가능**하며, **한 번 값이 할당되고 나면 다신 바꿀 수 없으므로 선언과 동시에 초기화를 해야 한다**는 것입니다(변수의 선언, 초기화 등에 대해서는 바로 밑에서 살펴봅니다).

### 5.3. 변수

#### 1. 변수의 이름 - 식별자(Identifier)

이미 앞에서 언급하였기 때문에 변수의 원리에 대해서 짐작하고 계시겠지만, **변수**란 메모리 공간의 주소에 별칭을 부여하고 해당 별명을 통해 주소에 접근하는 것입니다. 즉, 변수 하나하나가 메모리 공간에 대응됩니다.

이 때 각 메모리마다 주소가 다 다르듯이 변수 역시 각각의 이름을 지어 주어야 합니다.

C에서 변수와 같이 이름을 지어 주어야 하는 요소들의 이름을 **식별자(Identifier)** 라고 합니다. 각각의 요소들을 다른 요소들과 구분해 식별할 수 있도록 해 준다는 의미입니다.

식별자를 규정하려면 다음과 같은 **규칙(Notation)** 을 지켜야 합니다.

*   영어 대소문자와 숫자, 그리고 밑줄기호`_`만 사용할 수 있다.
*   첫 글자에는 숫자가 올 수 없다.
*   공백 문자가 포함될 수 없다.
*   C **문법에서 이미 사용되는 용어(이들을 가리켜 예약어라 합니다)** 를 사용할 수 없다.

예약어에는 다음과 같은 것들이 있습니다.

*   main
*   for
*   goto
*   while
*   int
*   short
*   double
*   const
*   그 외 기타

즉, 문법 용어로서 이미 쓰이는 단어들은 사용할 수 없다는 뜻입니다.

예시 코드로 간단히 올바른 식별자와 올바르지 않은 식별자를 확인해 보겠습니다.

```c
/*올바른 예시들*/
int a;
int _bb;
double aA13;
float GRAVITY_;

/*올바르지 않은 예시들*/
short 1a;				// 첫 문자로 숫자가 올 수 없다.
int double;				// 예약어를 사용할 수 없다.
char while;				// 예약어를 사용할 수 없다.
const int const;		// 예약어를 사용할 수 없다.
int my arr;				// 공백 문자가 포함될 수 없다.
int 총합;					//영어 대소문자, 숫자, 밑줄기호 외 문자를 사용할 수 없다.
```

또, 대문자와 소문자는 서로 구분됩니다(대문자와 소문자의 ASCII Code가 다르니 당연하겠죠?)

```c
/*아래 네 변수는 모두 다 다른 변수이다.*/
int age;
int Age;
int aGe;
int AGE;
```

식별자를 명명하는 **규칙**은 정해져 있지만 식별자를 명명하는 **방식**은 개발자마다, 그리고 프로젝트마다 다 다릅니다.

다양한 식별자 명명 방식은 [부록.4](./7.부록.md)를 참고해보세요.

#### 2. 변수 선언과 초기화

이제 변수의 사용 방법을 알아봅시다.

먼저 변수를 사용하겠다고 프로그램에 작성하는 것을 **선언(Declaration)** 이라고 합니다.

변수 선언 시 다음과 같은 형태로 선언해야 합니다.

```c
키워드 자료형 변수명(식별자);
```

예를 들면 다음과 같습니다.

```c
char letter;
const short tall;
int a;
```

이렇게 변수를 선언하고 나면 원하는 대로 값을 저장하거나, 필요할 때 저장된 값을 사용할 수 있습니다.

```c
int a;
a = 3;

printf("%d", a);
```

그런데 이 때 만약 변수를 선언한 후 값을 저장하지 않고 안의 값을 사용하려 하면 어떻게 될까요?

```c
int a;

printf("%d", a);
```

결과는 **아무도 모른다**입니다. 컴파일러에 따라 오류로 간주해 빌드가 불가하다고 판단하는 경우도 있으며, 값을 출력은 해 주지만 전혀 알 수 없는 값(이를테면 -442325823)이 출력되기도 합니다. 그리고 이 알수 없는 값은 프로그램 실행 시 마다 다른 값이 나오게 됩니다!

이처럼 변수를 선언한 후 값을 저장하지 않고 사용하게 될 때 나타나는 **예측 불가능한 값**을 **쓰레기값(Garbage Value)** 이라고 부릅니다.

쓰레기 값이 왜 생기는지는 한번 직접 고민해보세요! (고민 안하고 그냥 물어보셔도 됩니다)

아무튼, C 문법에서는 이러한 쓰레기값의 위험성 때문에 선언 직후 바로 scanf등을 이용해 외부에서 값을 입력받을 변수가 아니라면 선언과 동시에 값을 넣어주는 것을 권장합니다.

이 때 선언과 동시에 값을 넣어주는 것을 **초기화(Initialize)** 라고 합니다.

초기화는 다음과 같은 형태로 진행합니다.

```c
키워드 자료형 변수명(식별자) = 값;
```

예를 들면 다음과 같습니다.

```c
char letter = 'T';
const short tall = 182;
int a = 33824748;
```

간단하죠? 이처럼 **선언 시 초기화를 진행하면 해당 변수에 쓰레기 값이 존재할 여지가 없으므로 안전한 코드를 작성할 수 있습니다.**

#### 3. 변수의 사용 방법

이렇게 변수에 값을 저장하면 사용할 수도 있겠죠? 변수의 사용 방법은 무궁무진하고, 각각의 문법 시간마다 배우게 되므로 printf 와 scanf를 통한 입출력, 그리고 변수와 변수 간에 값을 복사하는 방법만 간단히 살펴봅시다.

##### 1. printf

이미 알고 있겠지만 printf 함수를 통해 변수 값을 출력할 때에는 다음과 같이 사용합니다.

```c
printf("형식_지정자를_포함한_문자열", 변수명);
```

##### 2. scanf

scanf 함수를 통해 변수에 값을 입력받을 때에는 다음과 같이 사용합니다.

```c
scanf("형식_지정자", &변수명);
```

미리 알아두시면 좋은 점은, 변수명 앞에 '&'를 붙이면 해당 변수의 주소가 된다는 점입니다. 즉 scanf는 매개변수로 **주소**가 들어갑니다.

##### 3. 변수 간의 값 복사

```c
int a = 3;
int b = a;

int c;
c = b;
```

초기화를 진행할 때 리터럴 상수를 저장하듯이 변수를 통해서도 초기화가 가능하며, 이렇게 초기화를 하게 되면 값을 주는 변수의 값이 **복사**되어 제공됩니다.

----

*(C) 2021. Im-Yongsik(Hamsik2rang) all rights reserved.*

<div style="text-align:left"> <a href="./4.자료형.md">← 자료형</a><div/>

<div style="text-align:right"> <a href="./6.연산자.md">연산자 →</a><div/>