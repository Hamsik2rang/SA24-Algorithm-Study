# C 학습 2주차

## 목차

1.  **개요**
    1.  흐름 제어(Flow Control)란?
    2.  C의 흐름 제어 문법 살펴보기
2.  **조건문(Conditional Statemen)**
    1.  if
        1.  if의 사용법과 의미
        2.  if ~ else if
        3.  if ~ else
        4.  if ~ else if ~ else
        5.  중첩 if
    2.  switch
        1.  switch의 사용법과 의미
        2.  break와 default
        3.  Fallthrough(의도적인 non-breaking)
    3.  조건문 사용 시 주의사항
3.  **반복문(Iteration Statement)**
    1.  블록(Block)과 범위
    2.  for
        1.  for의 사용법과 의미
        2.  for의 구성 요소
        3.  for의 동작 원리와 순서
        4.  중첩 for
    3.  while
        1.  while의 사용법과 의미
        2.  while의 구성 요소
        3.  while의 동작 원리와 순서
        4.  중첩 while
    4.  do-while
        1.  do-while의 사용법과 의미
        2.  do-while의 구성 요소
        3.  do-while의 동작 원리와 순서
    5.  무한 루프(Infinity Loop)
    6.  반복문 사용 시 주의사항
4.  **분기문(Branch Statement)**
    1.  분기문의 역할과 필요한 이유
    2.  break
    3.  continue
    4.  return
    5.  goto
        1.  goto의 사용법과 의미
        2.  사용을 권장하지 않는 이유

---

## 1. 분기문의 역할과 필요한 이유

앞서 살펴본 반복문이나 조건문(switch)의 경우, 원하는 상황에서 더 이상 해당 블록에 있지 않고 그 밖으로 빠져나가는 등의 역할을 위해 **break**라는 분기문을 사용했습니다.

이처럼 프로그램 실행 도중 조건에 따라 분기를 달리 하여 프로그램 흐름의 위치를 바꾸도록 하는 문법을 **분기문(Branch Statement)** 이라고 합니다.

참고로 goto를 제외한 모든 분기문은 **조건문**과 함께 사용되므로 단독적으로는 사용될 수 없습니다(또한 goto도 단독 사용이 가능하긴 하지만 거의 항상 조건문과 함께 사용됩니다).

## 2. break

**break**는 앞서 여러번 살펴본 것 처럼 프로그램 흐름을 현재 블록 밖으로 내보내는 역할을 하는 분기문입니다.

다음과 같이 사용합니다.

```c
//조건문 안에서
{
    break;
}
```

break가 사용되는 예시 코드들을 하나씩 살펴 보겠습니다.

```c
int hp = 150;

while (1)
{
    if(hp <= 0)
    {
        break;
    }
    //...
}
```

위 코드는 플레이어의 체력 150이 여러 이벤트에 의해 0 이하로 떨어지게 되면 무한 루프를 탈출하도록 합니다.

```c
while (1)
{
	int menu;
	scanf("%d", &menu);
	
	printf("주문하실 커피 메뉴를 선택하세요.(0 입력 시 자판기 종료)");
	
	if(menu == 0)
	{
		break;
	}
	else if
	//...
}
```

위 코드는 커피 자판기에서 종료에 해당하는 정수 값을 입력받으면 메뉴 선택 반복문을 탈출하도록 합니다.

이처럼 보통 break는 일반적인 반복문에도 사용될 뿐 아니라 **무한 루프**에서 항상 사용됩니다.

## 3. continue

반복문이 실행되는 도중 특정 조건을 만족하면 **반복문 전체를 끝내는 것**이 아니라 수행중인 해당 반복문만 건너뛰고 다음 반복으로 넘어가기를 원할 때가 있습니다.

**continue** 분기문은 반복문 전체에서 탈출하는 **break**와 달리 조건이 성립하는 순간 진행중인 반복을 건너뛰고 다음 반복으로 넘어가는(정확히는 반복 조건 판단으로 넘어가는) 분기문입니다.

continue 분기문을 아주 쉽게 이해할 수 있는 예시 코드를 하나 소개하겠습니다.

```c
#include <stdio.h>

int main()
{
    for (int i = 0; i < 10; i++)
    {
        if(i % 2 == 0)
            continue;
        printf("%d\n", i);
    }
	
    return 0;
}
```

위 코드의 실행 결과는 다음과 같습니다.

```text
1
3
5
7
9
```

i를 2로 나눈 나머지가 0이라면(즉, 짝수라면) 해당 반복문을 건너뛰고 다음 반복으로 넘어갑니다. 따라서 10보다 작은 홀수만이 출력되게 됩니다.

## 4. return

**return** 분기문은 break보다 더 강한 탈출을 지원하는 분기문입니다. break의 경우 break가 호출된 반복문의 밖으로 흐름을 이동시키지만, return은 호출된 **함수**의 밖으로 흐름을 이동시킵니다. 정확히는 **함수**가 아닌 **프로시저** 단위의 탈출이지만, C에서는 프로시저가 곧 함수이므로 함수 밖으로 탈출하는 것으로 이해하면 됩니다.

아직 함수를 배우지 않아 정확한 용법을 소개하긴 어렵지만, 예시 코드를 들어 살펴보겠습니다.

```c
#include <stdio.h>

int main()
{
    for(int i = 0; i < 10; i++)
    {
        if(i == 5)
            break;
        printf("%d ", i);
    }
    printf("\n");
    
    for(int i = 10; i < 20; i++)
    {
        if(i == 15)
            return;
        printf("%d ", i);
    }
    printf("\n");
    
    for(int i = 50; i < 60; i++)
    {
        if(i == 55)
            continue;
        printf("%d", i);
    }
}
```

위 코드의 출력 결과는 다음과 같습니다.

```text
0 1 2 3 4
10 11 12 13 14
```

두 번째 for문에서 i가 15가 되는 순간 return 분기문이 실행됩니다. 이 때 해당 return이 위치한 **함수**는 **main함수**이므로 **main함수 밖으로 실행 흐름을 탈출시켜 버립니다!** 

C에서 프로그램은 곧 main함수를 의미하므로 **main함수 밖으로 나간다는 말은 프로그램이 종료**된다는 뜻입니다. 따라서 마지막 for문은 수행되지 않고 종료됩니다.

사실 return이 해당 함수의 밖으로 흐름을 탈출시킨다는 말은 조금 모호한 표현입니다. 정확환 표현은 **함수**를 소개할 때 나중에 알아보도록 합시다.

## 5. goto

**goto**는 다른 분기문들이 정해진 기능대로만 분기 흐름을 변경(break는 위치한 반복문의 밖으로, return은 위치한 함수의 밖으로 등)하는 것과 달리, 분기 흐름을 프로그래머가 **원하는 대로** 변경할 수 있는 분기문입니다.

goto는 다음과 같이 사용합니다.

```c
goto 레이블_이름;
```

레이블이란, switch의 case처럼 **콜론`:` **으로 끝나는 문장을 말합니다. goto 레이블의 식별자는 프로그래머가 원하는 대로 지정 가능하며, 위치도 원하는 대로 지정할 수 있습니다.

레이블은 다음과 같이 배치합니다.

```c
레이블_이름:
```

예시 코드로 살펴보겠습니다.

```c
#include <stdio.h>

int main()
{
    int x = 3;
    
    goto my_label;
    x += 337;
    
my_label:
    
    printf("%d", x);
}
```

위 코드는 다음과 같이 출력 결과가 나타납니다.

```text
3
```

x에 337을 더하는 코드 앞에 goto가 나타났고, my_label은 x += 337;보다 뒤에 위치하므로 x += 337;이라는 문장이 수행되지 않게 됩니다.

이렇듯 goto는 프로그래머가 원하는 대로 실행 흐름을 구성할 수 있는 매우 강력한 기능을 제공하지만, 일반적으로 **사용하지 않는 것을 권고**하는 문법입니다.

고전 프로그래밍 언어나 어셈블리어에는 현대 프로그래밍 언어처럼 다양한 흐름 제어 문법이 없었기 때문에 goto를 사용해 while, for등을 구현해야 했지만, C 처럼 다른 반복문이나 분기문, 조건문들이 존재하는데 굳이 goto를 쓸 필요가 없기 때문입니다.

또한, 무엇보다 goto를 남발하게 되면 **코드의 가독성이 극도로 저하됩니다.**

이처럼 goto를 사용해 그 실행 흐름을 종잡을 수 없는 코드를 마치 스파게티처럼 꼬였다 하여 **스파게티 코드(Spagetti Code)** 라고 부릅니다.

----

*(C) 2021. Im-Yongsik(Hamsik2rang) all rights reserved.*

<div style="text-align:left"> <a href="./3.반복문.md">← 반복문</a><div/>
<div style="text-align:right"> <a href="">마지막 페이지</a><div/>








